fn charset_5x6(dots: &str) -> Option<char> {
    match dots {
        ".##.. #..#. #..#. ####. #..#. #..#." => Some('A'),
        "###.. #..#. ###.. #..#. #..#. ###.." => Some('B'),
        ".##.. #..#. #.... #.... #..#. .##.." => Some('C'),
        "####. #.... ###.. #.... #.... ####." => Some('E'),
        "####. #.... ###.. #.... #.... #...." => Some('F'),
        ".##.. #..#. #.... #.##. #..#. .###." => Some('G'),
        "#..#. #..#. ####. #..#. #..#. #..#." => Some('H'),
        ".###. ..#.. ..#.. ..#.. ..#.. .###." => Some('I'),
        "..##. ...#. ...#. ...#. #..#. .##.." => Some('J'),
        "#..#. #.#.. ##... #.#.. #.#.. #..#." => Some('K'),
        "#.... #.... #.... #.... #.... ####." => Some('L'),
        ".##.. #..#. #..#. #..#. #..#. .##.." => Some('O'),
        "###.. #..#. #..#. ###.. #.... #...." => Some('P'),
        "###.. #..#. #..#. ###.. #.#.. #..#." => Some('R'),
        ".###. #.... #.... .##.. ...#. ###.." => Some('S'),
        "#..#. #..#. #..#. #..#. #..#. .##.." => Some('U'),
        "#...# #...# .#.#. ..#.. ..#.. ..#.." => Some('Y'),
        "####. ...#. ..#.. .#... #.... ####." => Some('Z'),
        _ => None,
    }
}

/// Toto
/// # Panics
/// if no line in input string.
#[must_use]
pub fn scan_5x6(text: &str) -> String {
    let lines = text.lines().collect::<Vec<&str>>();

    let width = lines.iter().map(|x| x.len()).min().unwrap();

    let mut x = 0;
    let mut result = String::new();

    while x < width - 5 + 1 {
        let key = (0..6)
            .map(|y| &lines[y][x..(x + 5)])
            .collect::<Vec<&str>>()
            .join(" ");

        if let Some(letter) = charset_5x6(&key) {
            result.push(letter);
            x += 5;
        } else {
            x += 1;
        }
    }

    result
}

fn charset_6x10(dots: &str) -> Option<char> {
    match dots {
        "..##.. .#..#. #....# #....# #....# ###### #....# #....# #....# #....#" => Some('A'),
        "#####. #....# #....# #....# #####. #....# #....# #....# #....# #####." => Some('B'),
        ".####. #....# #..... #..... #..... #..... #..... #..... #....# .####." => Some('C'),
        "###### #..... #..... #..... #####. #..... #..... #..... #..... ######" => Some('E'),
        "###### #..... #..... #..... #####. #..... #..... #..... #..... #....." => Some('F'),
        ".####. #....# #..... #..... #..... #..### #....# #....# #...## .###.#" => Some('G'),
        "#....# #....# #....# #....# ###### #....# #....# #....# #....# #....#" => Some('H'),
        "...### ....#. ....#. ....#. ....#. ....#. ....#. #...#. #...#. .###.." => Some('J'),
        "#....# #...#. #..#.. #.#... ##.... ##.... #.#... #..#.. #...#. #....#" => Some('K'),
        "#..... #..... #..... #..... #..... #..... #..... #..... #..... ######" => Some('L'),
        "#....# ##...# ##...# #.#..# #.#..# #..#.# #..#.# #...## #...## #....#" => Some('N'),
        "#####. #....# #....# #....# #####. #..... #..... #..... #..... #....." => Some('P'),
        "#####. #....# #....# #....# #####. #..#.. #...#. #...#. #....# #....#" => Some('R'),
        "#....# #....# .#..#. .#..#. ..##.. ..##.. .#..#. .#..#. #....# #....#" => Some('X'),
        "###### .....# .....# ....#. ...#.. ..#... .#.... #..... #..... ######" => Some('Z'),
        _ => None,
    }
}

/// Toto
/// # Panics
/// if no line in input string.
#[must_use]
pub fn scan_6x10(text: &str) -> String {
    const CHAR_WIDTH: usize = 6;
    const CHAR_HEIGHT: usize = 10;

    let lines = text.lines().collect::<Vec<&str>>();

    let width = lines.iter().map(|x| x.len()).min().unwrap();

    let mut x = 0;
    let mut result = String::new();

    while x < width - CHAR_WIDTH + 1 {
        let key = (0..CHAR_HEIGHT)
            .map(|y| &lines[y][x..(x + CHAR_WIDTH)])
            .collect::<Vec<&str>>()
            .join(" ");

        if let Some(letter) = charset_6x10(&key) {
            result.push(letter);
            x += CHAR_WIDTH;
        } else {
            x += 1;
        }
    }

    result
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn ocr_5x6() {
        let crt = "\
####.#..#.###..####.#....###....##.###..
#....#..#.#..#....#.#....#..#....#.#..#.
###..####.###....#..#....#..#....#.#..#.
#....#..#.#..#..#...#....###.....#.###..
#....#..#.#..#.#....#....#.#..#..#.#.#..
####.#..#.###..####.####.#..#..##..#..#.
";
        assert_eq!(scan_5x6(crt), "EHBZLRJR");
    }
}
