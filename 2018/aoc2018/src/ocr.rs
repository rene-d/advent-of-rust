use phf::phf_map;

static CHARSET_5X6: phf::Map<&'static str, char> = phf_map! {
    ".##.. #..#. #..#. ####. #..#. #..#." => 'A',
    "###.. #..#. ###.. #..#. #..#. ###.." => 'B',
    ".##.. #..#. #.... #.... #..#. .##.." => 'C',
    "####. #.... ###.. #.... #.... ####." => 'E',
    "####. #.... ###.. #.... #.... #...." => 'F',
    ".##.. #..#. #.... #.##. #..#. .###." => 'G',
    "#..#. #..#. ####. #..#. #..#. #..#." => 'H',
    ".###. ..#.. ..#.. ..#.. ..#.. .###." => 'I',
    "..##. ...#. ...#. ...#. #..#. .##.." => 'J',
    "#..#. #.#.. ##... #.#.. #.#.. #..#." => 'K',
    "#.... #.... #.... #.... #.... ####." => 'L',
    ".##.. #..#. #..#. #..#. #..#. .##.." => 'O',
    "###.. #..#. #..#. ###.. #.... #...." => 'P',
    "###.. #..#. #..#. ###.. #.#.. #..#." => 'R',
    ".###. #.... #.... .##.. ...#. ###.." => 'S',
    "#..#. #..#. #..#. #..#. #..#. .##.." => 'U',
    "#...# #...# .#.#. ..#.. ..#.. ..#.." => 'Y',
    "####. ...#. ..#.. .#... #.... ####." => 'Z',
};

pub fn ocr_5x6(text: &str) -> String {
    let lines = text.lines().collect::<Vec<&str>>();

    let width = lines.iter().map(|x| x.len()).min().unwrap();

    let mut x = 0;
    let mut result = String::new();

    while x < width - 5 + 1 {
        let key = (0..6)
            .map(|y| &lines[y][x..(x + 5)])
            .collect::<Vec<&str>>()
            .join(" ");

        if let Some(letter) = CHARSET_5X6.get(&key) {
            result.push(*letter);
            x += 5;
        } else {
            x += 1;
        }
    }

    result
}

static CHARSET_6X10: phf::Map<&'static str, char> = phf_map! {
    "..##.. .#..#. #....# #....# #....# ###### #....# #....# #....# #....#" => 'A',
    "#####. #....# #....# #....# #####. #....# #....# #....# #....# #####." => 'B',
    ".####. #....# #..... #..... #..... #..... #..... #..... #....# .####." => 'C',
    "###### #..... #..... #..... #####. #..... #..... #..... #..... ######" => 'E',
    "###### #..... #..... #..... #####. #..... #..... #..... #..... #....." => 'F',
    ".####. #....# #..... #..... #..... #..### #....# #....# #...## .###.#" => 'G',
    "#....# #....# #....# #....# ###### #....# #....# #....# #....# #....#" => 'H',
    "#....# #...#. #..#.. #.#... ##.... ##.... #.#... #..#.. #...#. #....#" => 'K',
    "#..... #..... #..... #..... #..... #..... #..... #..... #..... ######" => 'L',
    "#....# ##...# ##...# #.#..# #.#..# #..#.# #..#.# #...## #...## #....#" => 'N',
    "#####. #....# #....# #....# #####. #..... #..... #..... #..... #....." => 'P',
    "#####. #....# #....# #....# #####. #..#.. #...#. #...#. #....# #....#" => 'R',
    "#....# #....# .#..#. .#..#. ..##.. ..##.. .#..#. .#..#. #....# #....#" => 'X',
    "###### .....# .....# ....#. ...#.. ..#... .#.... #..... #..... ######" => 'Z',
};

pub fn ocr_6x10(text: &str) -> String {
    const CHAR_WIDTH: usize = 6;
    const CHAR_HEIGHT: usize = 10;

    let lines = text.lines().collect::<Vec<&str>>();

    let width = lines.iter().map(|x| x.len()).min().unwrap();

    let mut x = 0;
    let mut result = String::new();

    while x < width - CHAR_WIDTH + 1 {
        let key = (0..CHAR_HEIGHT)
            .map(|y| &lines[y][x..(x + CHAR_WIDTH)])
            .collect::<Vec<&str>>()
            .join(" ");

        if let Some(letter) = CHARSET_6X10.get(&key) {
            result.push(*letter);
            x += CHAR_WIDTH;
        } else {
            x += 1;
        }
    }

    result
}
